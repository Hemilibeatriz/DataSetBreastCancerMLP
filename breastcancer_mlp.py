# -*- coding: utf-8 -*-
"""Cópia de Aula2810-BreastCancer_IRIS- MLP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1V0BUpjBVwDUSyff4DbXEd8SMbJqU3l_Q
"""

import numpy as np
from sklearn import datasets

def sigmoid(soma):
  return 1/(1+np.exp(-soma))

def sigmoidDerivada(sig):
    return sig*(1-sig)

base = datasets.load_breast_cancer()
#base = datasets.load_iris()

entradas = base.data[:100]
valoresSaida = base.target[:100]

quantidade_saidas=valoresSaida.shape[0]
quantidade_entradas=entradas.shape[1]

saidas = np.empty([quantidade_saidas,1], dtype=int)

for i in range(quantidade_saidas):
    saidas[i]= valoresSaida[i]

pesos0= 2*np.random.random((quantidade_entradas,5)) - 1
pesos1= 2*np.random.random((5,1)) - 1


epocas=3000
taxaAprendizagem = 0.01
momento = 1

x=[]
y=[]
for j in range(epocas):
  camadaEntrada = entradas
  somaSinapese0 = np.dot(camadaEntrada,pesos0)
  camadaOculta = sigmoid(somaSinapese0)
  somaSinapese1 = np.dot(camadaOculta, pesos1)
  camadaSaida = sigmoid(somaSinapese1)

  erroCamadaSaida=saidas-camadaSaida
  mediaAbsoluta=np.mean(np.abs(erroCamadaSaida))
  if (j % 100 == 0) & (j!=0):
    print("Erro: " + str(mediaAbsoluta)) 
    x.append(j)
    y.append(mediaAbsoluta)

  derivadaSaida = sigmoidDerivada(camadaSaida)
  deltaSaida = erroCamadaSaida * derivadaSaida

  #preciso da transposta para fazer a multiplicação da saída pelos pesos 1
  pesos1Transposta=pesos1.T
  deltaSaidaXPeso=deltaSaida.dot(pesos1Transposta)  
  deltaCamadaOculta=deltaSaidaXPeso * sigmoidDerivada(camadaOculta)

  camadaOcultaTransposta = camadaOculta.T
  pesosNovo1 = camadaOcultaTransposta.dot(deltaSaida)
  pesos1 = (pesos1 * momento) + (pesosNovo1 * taxaAprendizagem)

  camadaEntradaTransposta = camadaEntrada.T
  pesosNovo0 = camadaEntradaTransposta.dot(deltaCamadaOculta)
  pesos0 = (pesos0 * momento) + (pesosNovo0 * taxaAprendizagem)

from matplotlib.pyplot import *
from numpy import *
plot(x,y)
xlabel("Iteração")
ylabel("erro")
ylim(top=max(y), bottom=min(y))  # adjust the top leaving bottom unchanged

show()

